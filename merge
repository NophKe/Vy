diff --git a/filetypes/basefile.py b/filetypes/basefile.py
index 759cb9a..11d90e9 100644
--- a/filetypes/basefile.py
+++ b/filetypes/basefile.py
@@ -114,16 +114,16 @@ class BaseFile:
     BaseFile is... ( well... ) the basis for what is usually called a «buffer» 
     in the in the Vi-like editors jargon.
 
-    It mix the classical expected features of a mutable string with some traditionnal 
-    concepts of vim buffers, like mouvements.
+    It mix the classical expected features of a mutable string with some 
+    traditionnal concepts of vim buffers, like mouvements.
     
     >>> file = BaseFile(init_text='Hello World\n\t42\t\nno End-of-file?', cursor=0)
     >>> file.move_cursor('w')           # moves to next word ( regex \b )
     >>> assert file[:11] == file[':$']  # vim style buffer slice ( regex ^.*$ ) 
 
-    All of its public methods are atomic (using an internal threading.RLock object).
-    If you need to keep the object around, you can acquire its internal lock by 
-    using it as a context manager.
+    All of its public methods are atomic (using an internal threading.RLock 
+    object). If you need to modify the buffer, you can acquire its internal 
+    lock by using it as a context manager.
     
     >>> with file:
     ...     assert file.number_of_lin == len(file.splited_lines) \
@@ -244,42 +244,9 @@ class BaseFile:
         
         """
         try:
-            cursor = self._cursor
-            line_off = self._lines_offsets
-
-            if lin_off and cursor:
-                lin, offset = lin_off
-                return len(line_off), lin, cursor - offset +1
-
-            splited_line = self._splited_lines
-            lin_col = self._cursor_lin_col
-            max_index = self._number_of_lin
-
-            if lin_col:
-                if splited_line and max_index:
-                    assert len(splited_line) == max_index
-                    return max_index, lin_col[0], lin_col[1]
-
-                if line_off and splited_line:
-                    assert len(line_off) == len(splited_line)
-                    return len(splited_line), lin_col[0], lin_col[1]
-
-                if line_off and max_index:
-                    assert len(line_off) == max_index
-                    return max_index, lin_col[0], lin_col[1]
-
-            if lin_off and cursor:
-                lin, offset = lin_off
-                return len(line_off), lin, cursor - offset +1
-
-            if cursor == 0:
-                if splited_line and line_off:
-                    assert len(line_off) == len(splited_line)
-                    return (len(splited_line), 0, 1)
-                if line_off:
-                    return (len(splited_line), 0, 1)
-                if splited_line:
-                    return (len(splited_line), 0, 1)
+            lin, col = self._cursor_lin_col
+            nb_lin = self._number_of_lin
+            return nb_lin, lin, col
         except:
             raise RuntimeError
         raise RuntimeError
@@ -295,7 +262,7 @@ class BaseFile:
         with self._lock:
             if not self._cursor_lin_col:
                 lin, off = self.cursor_lin_off
-                #assert lin < self.number_of_lin
+                assert lin < self.number_of_lin
                 col = self.cursor - off + 1
                 self._cursor_lin_col = (lin, col)
             return self._cursor_lin_col
@@ -309,31 +276,14 @@ class BaseFile:
         with self._lock:
             old_lin, old_col = self.cursor_lin_col
             new_lin, new_col = pair_value
-            assert new_col > 0
-            assert self.number_of_lin > new_lin >= 0
-
-            if old_lin == new_lin:
-                if new_col > len(self.current_line):
-                    new_col = len(self._current_line)
-                self._cursor = self.lines_offsets[old_lin] + new_col
-                self._cursor_lin_col = (old_lin, new_col)
+            nb_lin = self.number_of_lin
 
-            else:
-                max_col = len(self.splited_lines[new_lin])
-                line_off = self.lines_offsets[new_lin]
-                max_cursor = line_off + max_col
-                try:
-                    assert self._lines_offsets[new_lin+1] == max_cursor
-                except IndexError: 
-                    pass
-                
-                if new_col > max_col:
-                    self._cursor = max_cursor
-                    self._cursor_lin_col = (new_lin, max_col)
-                else:
-                    self._cursor = line_off + new_col
-                    self._cursor_lin_col = (new_lin, new_col)
-                self._current_line = self.splited_lines[new_lin]
+            new_lin = min(nb_lin-1, max(0, new_lin))
+            self._current_line = self.splited_lines[new_lin]
+            new_col = max(1, min(new_col, len(self._current_line)))
+            
+            self._cursor = self.lines_offsets[new_lin] + new_col - 1
+            self._cursor_lin_col = (new_lin, new_col)
 
     @property
     def cursor_lin_off(self):
@@ -394,11 +344,10 @@ class BaseFile:
             if not self._splited_lines:
                 self._splited_lines = self._string.splitlines(True)
 
-                if self._number_of_lin:
-                    assert len(self._splited_lines) == self._number_of_lin
-
-                if self._lines_offsets:
-                    assert len(self._splited_lines) == len(self._lines_offsets)
+                #assert not self._number_of_lin or \
+                        #len(self._splited_lines) == self._number_of_lin
+                #assert not self._lines_offsets or \
+                        #len(self._splited_lines) == len(self._lines_offsets)
 
             return self._splited_lines
 
@@ -409,26 +358,10 @@ class BaseFile:
         """
         with self._lock:
             if not self._number_of_lin:
-                if self._splited_lines and self._lines_offsets:
-                    assert len(self._splited_lines) == len(self._lines_offsets)
-                    rv = len(self._splited_lines)
-
-                elif self._string and self._splited_lines:
-                    rv = self._string.count('\n') 
-                    assert rv == len(self.splited_lines)#, f'{len(self.splited_lines) = } {rv = }'
-
-                elif self._string and self._lines_offsets:
-                    rv = self._string.count('\n') 
-                    assert rv == len(self._lines_offsets)#, f'{len(self.splited_lines) = } {rv = }'
-
-                elif self._string:
-                    rv = self._string.count('\n')
-                    assert rv == len(self.splited_lines)
-
-                elif self._splited_lines:
-                    rv = len(self._splited_lines)
-                    assert rv == self._string.count('\n')
-                self._number_of_lin = rv
+                if self._splited_lines:
+                    self._number_of_lin = len(self._splited_lines)
+                else:
+                    self._number_of_lin = self._string.count('\n')
             return self._number_of_lin
 
     def suppr(self):
@@ -442,31 +375,19 @@ class BaseFile:
         '\n'
         """
         with self:
-            if self._splited_lines:
+            if self._splited_lines and self.current_line[:-1]:
                 lin, col = self.cursor_lin_col
-
-                if self[self.cursor] == '\n':
-                    self._splited_lines[lin] = (self._splited_lines[lin])[:-1] \
-                                             + self._splited_lines.pop(lin+1)
-                elif self._current_line:
-                    self._current_line  = f'{cur_lin[:col]}{cur_lin[col + 1:]}'
-                else:
-                    cur_lin = self._splited_lines[lin]
-                    self._splited_lines[lin] = f'{cur_lin[:col]}{cur_lin[col + 1:]}'
-
+                cur_lin = self.current_line
+                self._current_line  = f'{cur_lin[:col]}{cur_lin[col + 1:]}'
                 self._string = ''
-                if self._lenght is not None:
-                    self._lenght -= 1
-                if self._number_of_lin:
-                    self._number_of_lin -=1
+                self._lenght -= 1
+                self._lines_offsets.clear()
 
             elif self._string:
                 string = self.string
                 cur = self.cursor
                 self.string  = f'{string[:cur]}{string[cur + 1:]}'
 
-            else:
-                raise RuntimeError('Vy internal error. Buffer in inconsistent state.')
 
     def backspace(self):
         """
@@ -482,32 +403,40 @@ class BaseFile:
         Inserts value at the cursor position.
         Cursor will move to end of inserted text value.
         """
-        with self:
-            if value == '\n':
-                return self.insert_newline()
-
-            if self._splited_lines \
-            and (not '\n' in value) and (self[self.cursor] != '\n'):
-                    lin, col = self.cursor_lin_col
-                    string = self.current_line
-                    self._string = ''
-                    cur = col - 1
-                    self._cursor += len(value)
-                    self._cursor_lin_col = (lin, col + len(value))
-                    self._current_line = f'{string[:cur]}{value}{string[cur:]}'
-                    self._splited_lines[lin] = self._current_line
-                    self._lines_offsets.clear()
-
-                    if self._lenght is not None:
-                        delta = len(string) - len(value)
-                        self._lenght -= delta
-            else:
-                string = self.string
-                cur = self.cursor
-                self.string = f'{string[:cur]}{value}{string[cur:]}'
-                self.cursor += len(value)
+        if value:
+            with self:
+                if value == '\n':
+                    return self.insert_newline()
+                #elif '\n' not in value:
+                    #return self._list_insert(value)
+                else:
+                    return self._string_insert(value)
+
+    def _string_insert(self, value):
+        string = self.string
+        cur = self.cursor
+        self._string = f'{string[:cur]}{value}{string[cur:]}'
+        self._cursor += len(value)
+        self._number_of_lin = 0
+        self._lines_offsets.clear()
+        self._lenght = len(self._string)
+        self._current_line = ''
+        self._cursor_lin_col = ()
 
 
+    def _list_insert(self, value):
+        lin, col = self.cursor_lin_col
+        string = self.current_line
+        #assert string
+        self._string = ''
+        cur = col - 1
+        self._cursor += len(value)
+        self._cursor_lin_col = (lin, col + len(value))
+        self._current_line = f'{string[:cur]}{value}{string[cur:]}'
+        self._splited_lines[lin] = self._current_line
+        self._lines_offsets.clear()
+        self._lenght += len(value)
+
     def __init__(self, set_number=True, set_wrap=False, 
                 set_tabsize=4, cursor=0, init_text='', 
                 path=None):
@@ -585,10 +514,8 @@ class BaseFile:
             if self._lenght is None:
                 if self._string:
                     self._lenght = len(self._string) - len(self.ending)
-                elif self._splited_lines:
-                    self._lenght = sum(len(line) for line in self._splited_lines) - len(self.ending)
                 else:
-                    raise BaseException('vy internal error')
+                    self._lenght = sum(len(line) for line in self._splited_lines) - len(self.ending)
             return self._lenght
 
     #def delete_line(self, index):
@@ -603,26 +530,17 @@ class BaseFile:
 
     def insert_newline(self):
         r"""
-        This pretty complicated function inserts a newline using a «fast path».
+        This function inserts a newline using a «fast path».
 
-        It does do by checking what is allready being computed, delaying only
-        expensive computation.
+        It does do by checking what is allready being computed, and
+        delaying expensive computations.
         """
         with self:
-            assert self._splited_lines or self._string
-
-            if self._lenght is not None:
+            if self._splited_lines:
                 self._lenght += 1
-
-            if self._number_of_lin:
                 self._number_of_lin += 1
-
-            if self._cursor_lin_col:
-                lin, col = self._cursor_lin_col
-            else:
                 lin, col = self.cursor_lin_col
 
-            if self._splited_lines:
                 top = (self._splited_lines[lin])[:col-1] + '\n'
                 bottom = (self._splited_lines[lin])[col-1:]
                 self._splited_lines.insert(lin, top)
@@ -630,21 +548,20 @@ class BaseFile:
                 self._current_line = bottom
                 self._string = ''
                 self._cursor_lin_col = (lin+1, 1)
-                if self._cursor is not None:
-                    self._cursor += 1
+                self._cursor += 1
+                self._lines_offsets.clear()
 
-            elif self._string:
-                self.insert('\n')
+            else:
+                self._string_insert('\n')
 
-            self._lines_offsets.clear()
 
     @property
     def current_line(self):
         with self._lock:
             if not self._current_line:
                 self._current_line = self.splited_lines[self.cursor_line]
-            assert self._current_line.endswith('\n')
-            assert '\n' not in self._current_line[:-1]
+                assert self._current_line.endswith('\n') \
+                            and '\n' not in self._current_line[:-1]
             return self._current_line
 
     @current_line.setter
@@ -654,10 +571,7 @@ class BaseFile:
 
             lin, _ = self.cursor_lin_col
             old_val = self._splited_lines[lin]
-            
-            if self._lenght is not None:
-                delta = len(old_val) - len(value)
-                self._lenght -= delta
+            self._lenght -= len(old_val) - len(value)
 
             self._splited_lines[lin] = value
             self._string = ''
@@ -678,22 +592,15 @@ class BaseFile:
     @cursor.setter
     def cursor(self, value):
         with self._lock:
-            assert isinstance(value, int)
-            if self._lenght is not None:
-                assert self._lenght >= value, f'{self._lenght =} {value =} {(self) = }'
-                assert value >= 0, f'{value =} {len(self)}'
-            if self._cursor != value:
-                self._current_line = ''
-                self._cursor_lin_col = ()
-                self._cursor = value
+            self._current_line = ''
+            self._cursor_lin_col = ()
+            self._cursor = value
 
 
     @string.setter
     def string(self, value):
         with self:
-            assert isinstance(value, str)
-            assert self.modifiable
-            if self._string == value:
+            if not self.modifiable or self._string == value:
                 return
 
             self._current_line = ''
@@ -824,10 +731,6 @@ class BaseFile:
     def find_normal_k(self):
         with self._lock:
             lin, col = self.cursor_lin_col
-            if lin == 0:
-                return self.cursor
-            else:
-                return (lin-1, col)
 
             current_line_start = self.lines_offsets[lin]
             previous_line = self._lines_offsets[lin-1]
@@ -955,10 +858,8 @@ class BaseFile:
             #stop +=1
         #return slice(start, stop)
 
-
 ########    start of file-object capacities###########################
 
-
     def write(self, text):
         assert isinstance(text, str)
         if text:
@@ -995,10 +896,7 @@ class BaseFile:
     def move_cursor(self, offset_str):
         with self._lock:
             new_val = self._get_offset(offset_str)
-            if isinstance(new_val, int):
-                self.cursor = new_val
-            elif isinstance(new_val, tuple):
-                self.cursor_lin_col = new_val
+            self.cursor = new_val
     
     def __getitem__(self, key):
         with self._lock:
@@ -1173,6 +1071,14 @@ class BaseFile:
             return self.cursor
         return self.cursor - 1
 
+    #def suppr(self):
+        #"""
+        #Like the key strike, deletes the character under the cursor.
+        #"""
+        #string = self.string
+        #cur = self.cursor
+        #self.string  = f'{string[:cur]}{string[cur + 1:]}'
+
 if __name__ == '__main__':
     import doctest
     doctest.testmod()
